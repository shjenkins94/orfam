#!/bin/bash

set -eo pipefail

#######################################################################
#	Program: orfam
#	Version: 1.0
#	Author: Zuoyi Jian (jianzuoyi@qq.com)
#######################################################################

# global usage
function usage() {
	echo "
Program: orfam
Version: 1.0
Author: Zuoyi Jian (jianzuoyi@qq.com)

usage:   orfam <command> [options]

command: align 	align FASTA files with tblastn
         func 	identify intact olfactory receptor genes
         pseudo identify pseudo olfactory receptor genes
options: -h 	show this message
"
}


function source_binaries() {
	if [[ ! -e $1 ]]; then
		echo "Cannot find BIN. Make sure that it is a valid file: $BIN"
		func_usage
		exit 1
	fi

	FASTATOOLS=$BIN/fastatools.py
  FINDORF=$BIN/findorf.py
	CON_GAP=$BIN/con_gap.py
  START_CODON=$BIN/start_codon_debug.py
  PHYLO=$BIN/phylo_tree_debug.py
  PSEUDOGENE=$BIN/pseudogene.py

	for PYPACK in $FASTATOOLS $FINDORF $CON_GAP $START_CODON $PHYLO $PSEUDOGENE
	do
		if [[ ! -f $PYPACK ]]; then
			echo -e "Error: $PYPACK executable not found. Please make sure it is in $BIN"
			exit 1
		fi
	done
}


# alignment with tblastn
function align() {
	function align_usage() {
		echo "
usage:	orfam align [options]
options:
-Q FILE	known olfactory receptor proteins (FASTA) (required)
-S FILE	subject genome (FASTA) (required)
-O STR	output file [tabular]
-T DIR	temp directory [/tmpXXX]
-t INT	threads [1]
-E FLOAT	evalue for hits [1e-10]
-k	keep temporary directory
-v	verbose
-h	show this message

Required executables:
bioawk
TBLASTN
"
	}

	# verify arguments passed in.
	if [[ -z "$2" ]]; then
		align_usage
		exit 1
	fi

	# set defaults
	OUTPUT=""
	EVALUE=1e-10
	THREADS=1
	TEMP_DIR=""
	KEEP=false
	VERBOSE=false

	while getopts ":Q:S:O:T:t:E:kvh" OPTION; do
		case "$OPTION" in
		Q)
			QUERY="$OPTARG"
			;;
		S)
			SUBJECT="$OPTARG"
			;;
		O)
			OUTPUT="$OPTARG"
			;;
		T)
			TEMP_DIR="$OPTARG"
			KEEP=true
			;;
		t)
			THREADS="$OPTARG"
			;;
		E)
			EVALUE="$OPTARG"
			;;
		v)
			VERBOSE=true
			;;
		k)
			KEEP=true
			;;
		h)
			align_usage
			exit 1
			;;
		?)
			align_usage
			exit 1
			;;
		esac
	done

	# check the relevant binaries
	for DEPBIN in "bioawk" "makeblastdb" "tblastn" "bedtools"
	do
		hash $DEPBIN 2>/dev/null || { echo >&2 "$DEPBIN not found. Please check that it is installed"; align_usage; exit 1;}
	done

	# check that the required files exist
	if [[ ! -f $SUBJECT ]]; then
		align_usage
		echo -e "\nError: subject genome fasta file SUBJECT not found.\n"
		exit 1
	fi
	if [[ ! -f $QUERY ]]; then
		align_usage
		echo -e "\nError: olfactory receptor fasta file QUERY not found.\n"
		exit 1
	fi

	if [[ -z $OUTPUT ]]; then
		OUTPUT="$(basename $QUERY).gff"
	fi
    OUTBASE=$(basename $OUTPUT)

	# make temporary directory
	if [[ -z $TEMP_DIR ]]; then
		TEMP_DIR=$( mktemp -d tmpXXX )
	else
		mkdir -p $TEMP_DIR
	fi

	if $VERBOSE; then
	echo -e "Aligning...\n"
	fi

	#Filters out query sequences with lengths of less than 250
	#Creates a blast database for SUBJECT
	#Runs a tblastn search of the SUBJECT database
	#Moves the alignment to OUTPUT
	bioawk -c fastx 'length($2) >= 250 { print ">"$1"\n"$2}' $QUERY > $TEMP_DIR/query_length_ge_250aa.fa
  makeblastdb -dbtype nucl -in $SUBJECT -out $TEMP_DIR/"$(basename $SUBJECT)" -title "ref genome database" -parse_seqids
	if [[ "$?" -ne 0 ]]; then echo "Error: makeblastdb returned an error; exit now"; exit 1; fi

	tblastn -db $TEMP_DIR/"$(basename $SUBJECT)" -query $TEMP_DIR/query_length_ge_250aa.fa -out $TEMP_DIR/${OUTBASE}.tmp -evalue $EVALUE -outfmt 6 -num_threads $THREADS
	if [[ "$?" -ne 0 ]]; then echo "Error: tblastn returned an error; exit now"; exit 1; fi

	# Formats alignment as a GFF file
	# Sorts by strand, subject id and subject start position
	# Then uses bedtools to create clusters of hits with overlapping bases
	# The cluster for each hit is added on at the end in a new column
	cat $TEMP_DIR/${OUTBASE}.tmp |\
	awk -v OFS='\t' '{ if(($9<$10)) { strand="+" } else { strand="-"; tmp=$10; $10=$9; $9=tmp } print $2,"TBLASTN","similarity",$9,$10,$11,strand,".","qseqid="$1";qstart="$7";qend="$8";pident="$3";length="$4";mismatch="$5";gapopen="$6";bitscore="$12 }' |\
	sort -k7,7 -k1,1 -k4n,4 |\
	bedtools cluster -s -i /dev/stdin > $TEMP_DIR/blast_hit_clusters.gff
	if [[ "$?" -ne 0 ]]; then echo "Error: clustering hits returned an error; exit now"; exit 1; fi

	# Get best hits
	if $VERBOSE; then
		echo -e "Getting best hits...\n"
	fi

	# Adds another column with the bit score for each hit
	# Sorts by cluster, then e-score, then bit score
	# Takes the top hit for each cluster, discards hits with lengths of less than 50
	paste $TEMP_DIR/blast_hit_clusters.gff <(cat $TEMP_DIR/blast_hit_clusters.gff | cut -f 9 | cut -f 8 -d ';' | cut -f 2 -d '=') |\
	sort -k10n,10 -k6g,6 -k11gr,11 |\
	awk '!arr[$10]++' | cut -f 1-9 | awk '($5-$4+1)/3>=50' > $TEMP_DIR/${OUTBASE}_best_hit.gff.tmp
	if [[ "$?" -ne 0 ]]; then echo -e "Error: get best hits returned an error; exit now"; exit 1; fi

	if $VERBOSE; then
		wc -l $TEMP_DIR/${OUTBASE}_best_hit.gff.tmp | awk '{ print $1, "hits\n"}'
	fi

	# criteria 1
	if $VERBOSE; then
		echo -e "Criteria 1: discarding hits with less than 250 aa \n"
	fi

	awk '($5-$4+1)/3>=250' $TEMP_DIR/${OUTBASE}_best_hit.gff.tmp > $OUTPUT

# 	# ^ MAYBE PUT THIS IN ALIGN
#
	# criteria 2
	if $VERBOSE; then
		wc -l $OUTPUT | awk '{ print $1, "hits\n"}'
	fi

	# clean up
	if ! $KEEP ; then
		rm -r $TEMP_DIR
	fi

	echo "done."

	# exit cleanly
	exit 0
}


function func() {
	function func_usage() {
		echo "
usage:	orfam func [options]

options:
-S FILE	subject genome (FASTA) (required)
-H FILE orfam align output (GFF) (required)
-R FILE	reference sequences (FASTA) (required)
-I FILE table of reference sequence ids and which group they belong to (tabular) (required)
-b FILE	bed files for reference olfactory receptors (BED) (required)
-M FILE	settings for construction of phylogenetic tree (MAO)
-P STR	path to output file ending with a prefix for labeling output files (required)
-B DIR	location of orfam bin file [same directory as program]
-T DIR	temp directory [/tmpXXX]
-t INT	threads [1]
-k	keep temporary directory
-v	verbose
-h	show this message

Required executables:
bioawk
bedtools
mafft
megacc

Required Python modules:
biopython
	"
	}

	# check options passed in
	if [[ -z "$2" ]]; then
		func_usage
		exit 1
	fi

	# set defaults
	SUBJECT=""
	HITS=""
	ALL_REF=""
	ALL_ID=""
	ALL_BED=""
	MAO=""
	PREFIX=""
	BIN=$(dirname $0)
	THREADS=1
	TEMP_DIR=""
	KEEP=false
	VERBOSE=false

	while getopts ":S:H:R:I:b:M:P:B:T:t:kvh" OPTION; do
		case "$OPTION" in
			S)
				SUBJECT="$OPTARG"
				;;
			H)
				HITS="$OPTARG"
				;;
			R)
				ALL_REF="$OPTARG"
				;;
			I)
				ALL_ID="$OPTARG"
				;;
			b)
				ALL_BED="$OPTARG"
				;;
			M)
				MAO="$OPTARG"
				;;
			P)
				PREFIX="$OPTARG"
				;;
			B)
				BIN="$OPTARG"
				;;
			T)
				TEMP_DIR="$OPTARG"
				KEEP=true
				;;
			t)
				THREADS="$OPTARG"
				;;
			k)
				KEEP=true
				;;
			v)
				VERBOSE=true
				;;
			h)
				func_usage
				exit 1
				;;
			?)
				func_usage
				exit 1
				;;
		esac
	done

# Check for required inputs
	if [[ ! -f $SUBJECT ]]; then
		func_usage
		echo -e "\nError: -S FILE	subject genome (FASTA) not found.\n"
		exit 1
	fi
	if [[ ! -f $HITS ]]; then
		func_usage
		echo -e "\nError: -A orfam align output (tabular) not found.\n"
		exit 1
	fi

	if [[ ! -f $ALL_REF ]]; then
		func_usage
		echo -e "\nError: -R FILE	reference sequences (FASTA) not found.\n"
		exit 1
	fi

	if [[ ! -f $ALL_ID ]]; then
		func_usage
		echo -e "\nError: -b FILE	reference sequence ids (tabular) not found.\n"
		exit 1
	fi

	if [[ ! -f $ALL_BED ]]; then
		func_usage
		echo -e "\nError: -O FILE	reference sequence regions (BED) not found.\n"
		exit 1
	fi

	if [[ ! -f $MAO ]]; then
		func_usage
		echo -e "\nError: -M FILE	settings for construction of phylogenetic tree (MAO) not found.\n"
		exit 1
	fi

	if [[ -z $PREFIX ]]; then
		func_usage
		echo -e "\nError: -P STR	path to output file ending with a prefix for labeling output files not found.\n"
		exit 1
	fi

	# check for binaries included with orfam
	source_binaries $BIN

	python -c "import Bio" 2>/dev/null ||\
	{ func_usage; echo "Bio module not found. Please check that it is installed";  exit 1;}

	for depbin in "bioawk" "bedtools" "mafft" "megacc"
	do
		hash $depbin 2>/dev/null || { func_usage; echo >&2 "$depbin not found. Please check that it is installed"; exit 1;}
	done

	# make temporary directory
	if [[ -z "$TEMP_DIR" ]]; then
		TEMP_DIR=$( mktemp -d tmpXXX )
	else
		mkdir -p $TEMP_DIR
	fi

	OUTBASE=$( basename "$PREFIX" )
	OUT_BEST_HIT="${PREFIX}_best_hit.gff"
	OUT_INTACT="${PREFIX}_intact.fa"
	OUT_C1="${PREFIX}_intact_classI.gff"
	OUT_C2="${PREFIX}_intact_classII.gff"
	ALN_MAX=$(wc -l $ALL_ID | awk '{ print 200 -$1 }')

	awk -v tempdir=$TEMP_DIR '{ print $1 > tempdir "/" $2 "_id.txt" }' $ALL_ID
	awk -v tempdir=$TEMP_DIR '{ print $1, $2, $3 > tempdir "/" $4 ".bed" }' $ALL_BED

	cat $TEMP_DIR/1_id.txt $TEMP_DIR/2_id.txt |\
	python $FASTATOOLS extract $ALL_REF /dev/stdin > $TEMP_DIR/or_ref.fasta
	python $FASTATOOLS extract $ALL_REF $TEMP_DIR/0_id.txt > $TEMP_DIR/out_ref.fasta
	python $FASTATOOLS extract $ALL_REF $TEMP_DIR/1_id.txt > $TEMP_DIR/1_ref.fasta
	python $FASTATOOLS extract $ALL_REF $TEMP_DIR/2_id.txt > $TEMP_DIR/2_ref.fasta
	cat $TEMP_DIR/*_id.txt > $TEMP_DIR/rem_id.text
	OR_REF=$TEMP_DIR/or_ref.fasta
	OUTGROUP=$TEMP_DIR/out_ref.fasta
	REM_ID=$TEMP_DIR/rem_id.text
	C1_ID=$TEMP_DIR/1_id.txt
	OUT_ID=$TEMP_DIR/0_id.txt
	OR_TM=$TEMP_DIR/tm.bed


	if $VERBOSE; then
		echo -e "Criteria 2: add flanking sequences and find intact ORF (ATG ~ stop codon)\n"
	fi

	# Creates a file with subject chromosome/scaffold lengths for bedtools
	samtools faidx $SUBJECT
	cat $SUBJECT.fai |\
	cut -f 1,2 > $TEMP_DIR/sub.sizes

	# Uses bedtools to extend each hit 1000 bp in both directions, then uses
	# findorf.py to get potential orfs from all 3 reading frames on the same
	# strand. Each potential reading frame is then translated.
	bedtools slop -i $HITS -g $TEMP_DIR/sub.sizes -b 1000 |\
	python $FINDORF -S $SUBJECT -H /dev/stdin |\
	bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |\
	python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/open_reading_frame.fa

	if [[ "$?" -ne 0 ]]; then
		echo -e "Error: when finding opening reading frames."
		exit 1
	fi

	if $VERBOSE; then
		awk '/>/ { count++ } END { print count, "ORFs found\n"}' $TEMP_DIR/open_reading_frame.fa
	fi
	# criteria 3
	if $VERBOSE; then
		echo -e "Criteria 3: exclude sequences which have long gaps (>=5) in transmembrane regions.\n"
	fi

	# this divides the open reading frame file into fastas of 200 or less
	awk -v i=0 -v d=0 "/^>/ && i++%$ALN_MAX==0{s=\"$TEMP_DIR/open_reading_frame_\"++d\".fa\"} {print > s}" ${TEMP_DIR}/open_reading_frame.fa

	i=0
	for FASTA in $TEMP_DIR/open_reading_frame_*.fa; do
		i=$((i+1))

		# puts the commands to be run in a text file
		# Adds the reference OR to the open reading frames
		# Aligns the sequences with MAFFT
		# Sends alignment along with OR REF and OR REF TM bed file to tm_gap
		# Gets back the ids of sequences with gaps
		echo "
cat $FASTA $OR_REF |\
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin |\
python $CON_GAP -A /dev/stdin -B $OR_TM -G 4 |\
python $FASTATOOLS exclude $FASTA /dev/stdin > $TEMP_DIR/excluded_long_gap_${i}.fa
		"
		done > $TEMP_DIR/command.txt

	cat $TEMP_DIR/command.txt | parallel -j $THREADS

	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 3, exclude sequences with long gaps in transmembrane regions."
		exit 1
	fi

	rm $TEMP_DIR/open_reading_frame_*.fa
	cat $TEMP_DIR/excluded_long_gap_*.fa > $TEMP_DIR/excluded_long_gap.fa
	rm $TEMP_DIR/excluded_long_gap_*.fa

	if $VERBOSE; then
		awk '/>/ { count++ } END { print count, "remaining ORFs\n"}' ${TEMP_DIR}/excluded_long_gap.fa
	fi

	# criteria 4
	if $VERBOSE; then
		echo -e "Criteria 4: assigning a proper initiation codon\n"
	fi

	awk -v i=0 -v d=0 "/^>/ && i++%$ALN_MAX==0{s=\"$TEMP_DIR/excluded_long_gap_\"++d\".fa\"} {print > s}" ${TEMP_DIR}/excluded_long_gap.fa

	#Cycles through all the fasta files with intact TM regions
	i=0
	for FASTA in ${TEMP_DIR}/excluded_long_gap_*.fa; do
		i=$((i+1))

		#Sends REFERENCE, OR_REF, OR_TM and FASTA to start codon
		echo -e "
cat $FASTA $OR_REF |\
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin |\
python $START_CODON --orf_aln /dev/stdin --ref_or_tm $OR_TM --rem_id $REM_ID|\
bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |\
python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/assigned_start_codon_${i}.fa"
	done > $TEMP_DIR/command.txt

	cat $TEMP_DIR/command.txt | parallel -j $THREADS

	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 4, assigning a proper start codon."
		exit 1
	fi

	rm $TEMP_DIR/excluded_long_gap_*.fa

	cat $TEMP_DIR/assigned_start_codon_*.fa > $TEMP_DIR/assigned_start_codon.fa
	rm $TEMP_DIR/assigned_start_codon_*.fa

	if $VERBOSE; then
		awk '/>/ { count++ } END { print count, "remaining ORFs\n"}' $TEMP_DIR/assigned_start_codon.fa
	fi

	if $VERBOSE; then
		echo -e "Criteria 5: remove sequences that form clades with outgroup\n"
	fi

	awk "/^>/ && n++%$ALN_MAX==0{s=\"$TEMP_DIR/assigned_start_codon_\"++d\".fa\"} {print > s}" $TEMP_DIR/assigned_start_codon.fa

	awk '{print $0"=outgroup"}' $OUT_ID > "${TEMP_DIR}/outgroup.txt"

	i=0
	for FASTA in ${TEMP_DIR}/assigned_start_codon_*.fa; do
		i=$((i+1))
		echo "
cat $FASTA $OUTGROUP |\
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin > $TEMP_DIR/phylo_${i}_aln.fa
				"
	done > $TEMP_DIR/command.txt
	cat $TEMP_DIR/command.txt | parallel -j $THREADS

	i=0
	for FASTA in ${TEMP_DIR}/assigned_start_codon_*.fa; do
		i=$((i+1))
		echo "
megacc -a $MAO -d $TEMP_DIR/phylo_${i}_aln.fa -g ${TEMP_DIR}/outgroup.txt -o $TEMP_DIR/phylo_tree_${i}.nwk
				"
	done > $TEMP_DIR/command.txt
	cat $TEMP_DIR/command.txt | parallel -j $THREADS

	i=0
	for FASTA in ${TEMP_DIR}/assigned_start_codon_*.fa; do
		i=$((i+1))
		echo "
python $PHYLO $TEMP_DIR/phylo_tree_${i}.nwk $OUT_ID > ${TEMP_DIR}/non_or_within_outgroup_ids_${i}.txt
				"
	done > $TEMP_DIR/command.txt
	cat $TEMP_DIR/command.txt | parallel -j $THREADS

	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 5, remove sequences that form clades with outgroup"
		exit 1
	fi

	cat ${TEMP_DIR}/non_or_within_outgroup_ids_*.txt > ${TEMP_DIR}/non_or_within_outgroup_ids.txt
	rm ${TEMP_DIR}/non_or_within_outgroup_ids_*.txt
	rm ${TEMP_DIR}/assigned_start_codon_*.fa

	python $FASTATOOLS exclude ${TEMP_DIR}/assigned_start_codon.fa ${TEMP_DIR}/non_or_within_outgroup_ids.txt > ${TEMP_DIR}/outgroup_removed.fa

 	rm -f ${TEMP_DIR}/phylo_*

	if $VERBOSE; then
		awk '/>/ { count++ } END { print count, "remaining ORFs\n"}' ${TEMP_DIR}/outgroup_removed.fa
	fi


	if $VERBOSE; then
		echo -e "Criteria 6: divide into class I and class II ORs"
	fi

	awk "/^>/ && n++%$ALN_MAX==0{s=\"${TEMP_DIR}/outgroup_removed_\"++d\".fa\"} {print > s}" ${TEMP_DIR}/outgroup_removed.fa

	i=0
	for FASTA in ${TEMP_DIR}/outgroup_removed_aa_*.fa; do
		i=$((i+1))
		echo "
	cat $FASTA $ALL_REF |\
	mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin > $TEMP_DIR/phylo_${i}_aln.fa"
	done > $TEMP_DIR/command.txt

	cat $TEMP_DIR/command.txt | parallel -j $THREADS

	i=0
	for FASTA in ${TEMP_DIR}/outgroup_removed_aa_*.fa; do
		i=$((i+1))
		echo "
	megacc -a $MAO -d $TEMP_DIR/phylo_${i}_aln.fa -g ${TEMP_DIR}/outgroup.txt -o $TEMP_DIR/phylo_tree_${i}.nwk"
	done > $TEMP_DIR/command.txt

	cat $TEMP_DIR/command.txt | parallel -j $THREADS

	i=0
	for FASTA in ${TEMP_DIR}/outgroup_removed_aa_*.fa; do
		i=$((i+1))
		echo "
	python $PHYLO $TEMP_DIR/phylo_tree_${i}.nwk $OUT_ID -C $C1_ID > '${TEMP_DIR}/new_c1_ids_${i}.txt'"
	done > $TEMP_DIR/command.txt

	cat $TEMP_DIR/command.txt | parallel -j $THREADS


	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 6, divide into class I and class II ORs"
		exit 1
	fi

	rm $TEMP_DIR/outgroup_removed_*.fa
	cat ${TEMP_DIR}/new_c1_ids_*.txt > ${TEMP_DIR}/new_c1_ids.txt
	rm ${TEMP_DIR}/new_c1_ids_*.txt

	python $FASTATOOLS extract ${TEMP_DIR}/outgroup_removed.fa ${TEMP_DIR}/new_c1_ids.txt > ${TEMP_DIR}/potential_class_1.fa
	python $FASTATOOLS exclude ${TEMP_DIR}/outgroup_removed.fa ${TEMP_DIR}/new_c1_ids.txt > ${TEMP_DIR}/potential_class_2.fa

	rm -f $TEMP_DIR/phylo_tree_*


	if $VERBOSE; then
	awk '/>/ { count++ } END { print count, "potential class I ORs \n"}' ${TEMP_DIR}/potential_class_1.fa
	awk '/>/ { count++ } END { print count, "potential class II ORs \n"}' ${TEMP_DIR}/potential_class_2.fa
	fi

	if $VERBOSE; then
	echo -e "Criteria 7: Remove sequences with gaps in conserved areas\n"
	fi


	for C in 1 2; do
		if [[ -s ${TEMP_DIR}/potential_class_${C}.fa ]]; then

			awk "/^>/ && n++%$ALN_MAX==0{s=\"${TEMP_DIR}/potential_class_${C}_\"++d\".fa\"} {print > s}" ${TEMP_DIR}/potential_class_${C}.fa

			i=0
			for FASTA in ${TEMP_DIR}/potential_class_${C}_*.fa; do
				i=$((i+1))
				echo "
			cat $FASTA $TEMP_DIR/${C}_ref.fasta |\
			mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin |\
			python $CON_GAP -A /dev/stdin -B ${TEMP_DIR}/${C}.bed -G 2 -c > ${TEMP_DIR}/too_many_gaps_${C}_${i}.txt
			"
			done > $TEMP_DIR/command.txt

			cat ${TEMP_DIR}/command.txt | parallel -j $THREADS

			cat ${TEMP_DIR}/too_many_gaps_${C}_*.txt > ${TEMP_DIR}/too_many_gaps_${C}.txt
			python $FASTATOOLS exclude ${TEMP_DIR}/potential_class_${C}.fa ${TEMP_DIR}/too_many_gaps_${C}.txt > ${TEMP_DIR}/intact_${C}.fa

		fi

		if [[ -s ${TEMP_DIR}/intact_${C}.fa ]]; then
			awk -v c=$C '/>/ { count++ } END { print count, "intact class", c, "ORs found\n"}' ${TEMP_DIR}/intact_${C}.fa
		fi

	done

	cat ${TEMP_DIR}/intact_*.fa > $OUT_INTACT
	rm ${TEMP_DIR}/potential_class_*.fa
	rm ${TEMP_DIR}/too_many_gaps_*.txt

	if ! $KEEP ; then
		rm -r $TEMP_DIR
	fi

	echo "done."

	exit 0
}

# identify pseudo genes
function pseudo(){
	function pseudo_usage(){
		echo "
usage:	orfam pseudo [options]

options:
-S FILE	subject genome (FASTA) (required)
-Q FILE	known olfactory receptor proteins (FASTA) (required)
-H FILE orfam align output (GFF) (required)
-i FILE intact olfactory receptor (fasta) (required)
-P STR	path to output file ending with a prefix for labeling output files (required)
-B DIR	location of orfam bin file [same directory as program]
-T DIR	temp directory [/tmpXXX]
-k	keep temporary directory
-v	verbose
-h	show this message"
	}

	# check options passed in
	if [[ -z "$2" ]]; then
		pseudo_usage
		exit 1
	fi

	# set defaults
	SUBJECT=""
	QUERY=""
	HITS=""
	INTACT=""
	PREFIX=""
	BIN=$(dirname $0)
	TEMP_DIR=""
	PREFIX=""
	KEEP=false
	VERBOSE=false

	while getopts ":S:Q:H:i:P:B:T:kvh" OPTION; do
		case "$OPTION" in
			S)
				SUBJECT="$OPTARG"
				;;
			Q)
				QUERY="$OPTARG"
				;;
			H)
				HITS="$OPTARG"
				;;
			i)
				INTACT="$OPTARG"
				;;
			P)
				PREFIX="$OPTARG"
				;;
			B)
				BIN="$OPTARG"
				;;
			T)
				TEMP_DIR="$OPTARG"
				KEEP=true
				;;
			v)
				VERBOSE=true
				;;
			k)
				KEEP=true
				;;
			h)
				pseudo_usage
				exit 1
				;;
			?)
				pseudo_usage
				exit 1
				;;
		esac
	done



	# check that the required file exit
	if [[ ! -f $SUBJECT ]]; then
		pseudo_usage
		echo -e "\nrror: subject genome file $SUBJECT not found.\n"
		exit 1
	fi

	if [[ ! -f $QUERY ]]; then
		pseudo_usage
		echo -e "\nError: query proteins file $QUERY not found.\n"
		exit 1
	fi

	if [[ ! -f $HITS ]]; then
		pseudo_usage
		echo -e "\nError: best hits file $HITS not found.\n"
		exit 1
	fi

	if [[ ! -f $INTACT ]]; then
		pseudo_usage
		echo -e "\nError: intact gene file $INTACT not found.\n"
		exit 1
	fi

	if [[ -z $PREFIX ]]; then
		pseudo_usage
		echo -e "\nError: path to output file ending with a prefix for labeling output files not found.\n"
		exit 1
	fi

	# check the relevant binaries
	source_binaries $BIN

	python -c "import Bio" 2>/dev/null ||\
	{ func_usage; echo "Bio module not found. Please check that it is installed";  exit 1;}

	#make temporary directory
	if [[ -z "$TEMP_DIR" ]]; then
		TEMP_DIR=$( mktemp -d tmpXXX )
	else
		mkdir -p $TEMP_DIR
	fi

	if $VERBOSE; then
		echo -e "
		$PYTHON $PSEUDOGENE -s $SUBJECT -q $QUERY -b $HITS -i $INTACT -T $TEMP_DIR
		"
	fi

	python $PSEUDOGENE -s $SUBJECT -q $QUERY -b $HITS -i $INTACT -o $PREFIX -T $TEMP_DIR
}

# show usage when there are no arguments.
if [[ -z "$1" ]]; then
	usage
    exit 1
fi

while getopts "h:" OPTION; do
    case $OPTION in
        h)
            usage
            exit 1
            ;;
        ?)
            usage
            exit 1
            ;;
    esac
done

# call the function
case "$1" in
    'align')
    	align "${@:2}"
    	;;
    'func')
    	func "${@:2}"
    	;;
    'pseudo')
		pseudo "${@:2}"
		;;
    *)
    	usage
    	echo -e "Error: command \"$1\" is invalid\n"
    	exit 1
esac

## END SCRIPT
