#!/bin/bash

set -eo pipefail

#######################################################################
#	Program: orfam
#	Version: 1.0
#	Author: Zuoyi Jian (jianzuoyi@qq.com)
#######################################################################

# global usage
function usage() {
	echo "
Program: orfam
Version: 1.0
Author: Zuoyi Jian (jianzuoyi@qq.com)

usage:   orfam <command> [options]

command: align 	align FASTA files with tblastn
         func 	identify intact olfactory receptor genes
         pseudo identify pseudo olfactory receptor genes
options: -h 	show this message
"
}


function source_binaries() {
	if [[ ! -e $1 ]]; then
		echo "Cannot find BIN. Make sure that it is a valid file: $BIN"
		func_usage
		exit 1
	fi

	FASTATOOLS=$BIN/fastatools.py
  FINDORF=$BIN/findorf.py
	TM_GAP=$BIN/tm_gap_debug.py
  START_CODON=$BIN/start_codon_debug.py
  PHYLO=$BIN/phylo_tree_debug.py
  ROOT_WITH_OUTGROUP=$BIN/root_with_outgroup.py
  PSEUDOGENE=$BIN/pseudogene.py

	for PYPACK in $FASTATOOLS $FINDORF $TM_GAP $START_CODON $PHYLO $ROOT_WITH_OUTGROUP $PSEUDOGENE
	do
		if [[ ! -f $PYPACK ]]; then
			func_usage
			echo -e "Error: $PYPACK executable not found. Please make sure it is in $BIN"
			exit 1
		fi
	done
}


# alignment with tblastn
function align() {
	function align_usage() {
		echo "
usage:	orfam align [options]
options:
-Q FILE	known olfactory receptor proteins (FASTA) (required)
-S FILE	subject genome (FASTA) (required)
-O STR	output file [tabular]
-T DIR	temp directory [/tmpXXX]
-t INT	threads [1]
-E FLOAT	evalue for hits [1e-10]
-k	keep temporary directory
-v	verbose
-h	show this message

Required executables:
bioawk
TBLASTN
"
	}

	# verify arguments passed in.
	if [[ -z "$2" ]]; then
		align_usage
		exit 1
	fi

	# set defaults
	OUTPUT=""
	EVALUE=1e-10
	THREADS=1
	TEMP_DIR=""
	KEEP=false
	VERBOSE=false

	while getopts ":Q:S:O:T:t:E:kvh" OPTION; do
		case "$OPTION" in
		Q)
			QUERY="$OPTARG"
			;;
		S)
			SUBJECT="$OPTARG"
			;;
		O)
			OUTPUT="$OPTARG"
			;;

		T)
			TEMP_DIR="$OPTARG"
			;;
		t)
			THREADS="$OPTARG"
			;;
		E)
			EVALUE="$OPTARG"
			;;
		v)
			VERBOSE=true
			;;
		k)
			KEEP=true
			;;
		h)
			align_usage
			exit 1
			;;
		?)
			align_usage
			exit 1
			;;
		esac
	done

	# check the relevant binaries
	#source_binaries $CONFIG
	for DEPBIN in "bioawk" "makeblastdb" "tblastn"
	do
		hash $DEPBIN 2>/dev/null || { echo >&2 "$DEPBIN not found. Please check that it is installed"; align_usage; exit 1;}
	done

	# check that the required files exist
	if [[ ! -f $SUBJECT ]]; then
		align_usage
		echo -e "Error: subject genome fasta file SUBJECT not found.\n"
		exit 1
	fi
	if [[ ! -f $QUERY ]]; then
		align_usage
		echo -e "Error: olfactory receptor fasta file QUERY not found.\n"
		exit 1
	fi

	if [[ -z $OUTPUT ]]; then
		OUTPUT="$(basename $QUERY).txt"
	fi
    OUTBASE=$(basename $OUTPUT)

	# make temporary directory
	if [[ -z $TEMP_DIR ]]; then
		TEMP_DIR=$( mktemp -d tmpXXX )
	else
		mkdir -p $TEMP_DIR
	fi


	echo "Aligning..."
  if $VERBOSE ; then
   	echo "
bioawk -c fastx 'length(\$2) >= 250 { print \">\"\$1\"\n\"\$2}' $QUERY > $TEMP_DIR/query_length_ge_250aa.fa
makeblastdb -dbtype nucl -in $SUBJECT -out $TEMP_DIR/$(basename $SUBJECT) -title \"ref genome database\" -parse_seqids
tblastn -db $TEMP_DIR/$(basename $SUBJECT) -query $TEMP_DIR/query_length_ge_250aa.fa -out $TEMP_DIR/${OUTBASE}.tmp -evalue $EVALUE -outfmt 6 -num_threads $THREADS
mv $TEMP_DIR/${OUTBASE}.tmp $OUTPUT"
  fi

	#Filters out query sequences with lengths of less than 250
	#Creates a blast database for SUBJECT
	#Runs a tblastn search of the SUBJECT database
	#Moves the alignment to OUTPUT
	bioawk -c fastx 'length($2) >= 250 { print ">"$1"\n"$2}' $QUERY > $TEMP_DIR/query_length_ge_250aa.fa
  makeblastdb -dbtype nucl -in $SUBJECT -out $TEMP_DIR/"$(basename $SUBJECT)" -title "ref genome database" -parse_seqids
	if [[ "$?" -ne 0 ]]; then echo "Error: makeblastdb returned an error;exit now"; exit 1; fi
  tblastn -db $TEMP_DIR/"$(basename $SUBJECT)" -query $TEMP_DIR/query_length_ge_250aa.fa -out $TEMP_DIR/${OUTBASE}.tmp -evalue $EVALUE -outfmt 6 -num_threads $THREADS
	if [[ "$?" -ne 0 ]]; then echo "Error: tblastn returned an error;exit now"; exit 1; fi
	mv $TEMP_DIR/${OUTBASE}.tmp $OUTPUT

	# clean up
	if ! $KEEP ; then
		rm -r $TEMP_DIR
	fi

	echo "done."

	# exit cleanly
	exit 0
}


function func() {
	function func_usage() {
		echo "
usage:	orfam func [options]

NEW:
-S FILE	subject genome (FASTA)
-H FILE orfam align output (tabular) (required)
-R FILE	reference olfactory receptor (FASTA) (required)
-b FILE	transmembrane regions of reference olfactory receptor (BED) (required)
-O FILE	non-olfactory receptor sequences for outgroup (FASTA) (required)
-M FILE	settings for construction of phylogenetic tree (MAO)
-P STR	path to output file ending with a prefix for labeling output files (required)
-B DIR	location of orfam bin file [same directory as program]
-T DIR	temp directory [/tmpXXX]
-t INT	threads [1]
-k	keep temporary directory
-v	verbose
-h	show this message

Required executables:
bioawk
bedtools
mafft
megacc

Required Python modules:
biopython
	"
	}

	# check options passed in
	if [[ -z "$2" ]]; then
		func_usage
		exit 1
	fi

	# set defaults
	SUBJECT=""
	HITS=""
	OR_REF=""
	OR_TM=""
	OUTGROUP=""
	MAO=""
	PREFIX=""
	BIN=$(dirname $0)
	THREADS=1
	TEMP_DIR=""
	KEEP=false
	VERBOSE=false

	while getopts ":S:H:R:b:O:M:P:B:T:t:kvh" OPTION; do
		case "$OPTION" in
			S)
				SUBJECT="$OPTARG"
				;;
			H)
				HITS="$OPTARG"
				;;
			R)
				OR_REF="$OPTARG"
				;;
			b)
				OR_TM="$OPTARG"
				;;

			O)
				OUTGROUP="$OPTARG"
				;;
			M)
				MAO="$OPTARG"
				;;
			P)
				PREFIX="$OPTARG"
				;;
			B)
				BIN="$OPTARG"
				;;
			T)
				TEMP_DIR="$OPTARG"
				KEEP=true
				;;
			t)
				THREADS="$OPTARG"
				;;
			k)
				KEEP=true
				;;
			v)
				VERBOSE=true
				;;
			h)
				func_usage
				exit 1
				;;
			?)
				func_usage
				exit 1
				;;
		esac
	done

# Check for required inputs
	if [[ ! -f $SUBJECT ]]; then
		func_usage
		echo -e "Error: -S FILE	subject genome (FASTA) not found.\n"
		exit 1
	fi
	if [[ ! -f $HITS ]]; then
		func_usage
		echo -e "Error: -A orfam align output (tabular) not found.\n"
		exit 1
	fi

	if [[ ! -f $OR_REF ]]; then
		func_usage
		echo -e "Error: -R FILE	reference olfactory receptor (FASTA) not found.\n"
		exit 1
	fi

	if [[ ! -f $OR_TM ]]; then
		func_usage
		echo -e "Error: -b FILE	transmembrane regions of reference olfactory receptor (BED) not found.\n"
		exit 1
	fi

	if [[ ! -f $OUTGROUP ]]; then
		func_usage
		echo -e "Error: -O FILE	non-olfactory receptor sequences for outgroup (FASTA) (required) not found.\n"
		exit 1
	fi

	if [[ ! -f $MAO ]]; then
		func_usage
		echo -e "Error: -M FILE	settings for construction of phylogenetic tree (MAO) not found.\n"
		exit 1
	fi

	if [[ -z $PREFIX ]]; then
		func_usage
		echo -e "Error: -P STR	path to output file ending with a prefix for labeling output files not found.\n"
		exit 1
	fi

	# check for binaries included with orfam
	source_binaries $BIN

	python -c "import Bio" 2>/dev/null ||\
	{ func_usage; echo "Bio module not found. Please check that it is installed";  exit 1;}

	for depbin in "bioawk" "bedtools" "mafft" "megacc"
	do
		hash $depbin 2>/dev/null || { func_usage; echo >&2 "$depbin not found. Please check that it is installed"; exit 1;}
	done

	OUTBASE=$( basename "$PREFIX" )
	OUT_BEST_HIT="${PREFIX}_best_hit.gff"
	OUT_INTACT="${PREFIX}_intact.fa"
	MAFFT_MAX=200
	OR_REF_N=$(awk '/>/ { count++ } END { print count }' $OR_REF)
	ORF_MAX=$(($MAFFT_MAX - $OR_REF_N))

	if ((OR_REF_N > 50)); then
		func_usage
		echo -e "Error: -R has more than 50 sequences. Please use less."
		exit 1
	fi

	# make temporary directory
	if [[ -z "$TEMP_DIR" ]]; then
		TEMP_DIR=$( mktemp -d tmpXXX )
	else
		mkdir -p $TEMP_DIR
	fi

	python $FASTATOOLS id_list $OR_REF > $TEMP_DIR/rem_id.txt
	python $FASTATOOLS id_list $OUTGROUP > $TEMP_DIR/out_id.txt
	REM_ID=$TEMP_DIR/rem_id.txt
	OUT_ID=$TEMP_DIR/out_id.txt

	# Get best hits
	if $VERBOSE; then
		echo -e "\nGetting best hits..."
		echo -e "
cat $HITS |
awk -v OFS='\t' '{ if((\$9<\$10)) { strand=\"+\" }
else { strand=\"-\"; tmp=\$10; \$10=\$9; \$9=tmp }
print \$2,\"TBLASTN\",\"similarity\",\$9,\$10,\$11,strand,\".\",\"qseqid=\"\$1\";qstart=\"\$7\";qend=\"\$8\";pident=\"\$3\";length=\"\$4\";mismatch=\"\$5\";gapopen=\"\$6\";bitscore=\"\$12 }' |
sort -k7,7 -k1,1 -k4n,4 |
bedtools cluster -s -i /dev/stdin > $TEMP_DIR/blast_hit_clusters.gff

paste $TEMP_DIR/blast_hit_clusters.gff
<(cat $TEMP_DIR/blast_hit_clusters.gff | cut -f 9 | cut -f 8 -d ';' | cut -f 2 -d '=') |
sort -k10n,10 -k6g,6 -k11gr,11 |
awk '!arr[${10}]++' | cut -f 1-9 > $TEMP_DIR/${OUTBASE}_best_hit.gff.tmp
mv $TEMP_DIR/${OUTBASE}_best_hit.gff.tmp $OUT_BEST_HIT
"
	fi

	# Formats alignment as a GFF file
	# Sorts by strand, subject id and subject start position
	# Then uses bedtools to create clusters of hits with overlapping bases
	# The cluster for each hit is added on at the end in a new column
	cat $HITS |\
	awk -v OFS='\t' '{ if(($9<$10)) { strand="+" } else { strand="-"; tmp=$10; $10=$9; $9=tmp } print $2,"TBLASTN","similarity",$9,$10,$11,strand,".","qseqid="$1";qstart="$7";qend="$8";pident="$3";length="$4";mismatch="$5";gapopen="$6";bitscore="$12 }' |\
	sort -k7,7 -k1,1 -k4n,4 |\
	bedtools cluster -s -i /dev/stdin > $TEMP_DIR/blast_hit_clusters.gff

	# Adds another column with the bit score for each hit
	# Sorts by cluster, then e-score, then bit score
	# Takes the top hit for each cluster, discards hits with lengths of less than 50
	paste $TEMP_DIR/blast_hit_clusters.gff <(cat $TEMP_DIR/blast_hit_clusters.gff | cut -f 9 | cut -f 8 -d ';' | cut -f 2 -d '=') |\
	sort -k10n,10 -k6g,6 -k11gr,11 |\
	awk '!arr[$10]++' | cut -f 1-9 | awk '($5-$4+1)/3>=50' > $TEMP_DIR/${OUTBASE}_best_hit.gff.tmp
	mv $TEMP_DIR/${OUTBASE}_best_hit.gff.tmp $OUT_BEST_HIT

	if [[ "$?" -ne 0 ]]; then
		echo -e "Error: get best hits returned an error; exit now"
		exit 1
	fi

	# criteria 1
	if $VERBOSE; then
		wc -l $OUT_BEST_HIT | awk '{ print $1, "hits\n"}'
		echo -e "Criteria 1: discard hits which length is shorter than 250 aa.\n"
		echo -e "awk '(\$5-\$4+1)/3>=250' ${OUTBASE}_best_hit.gff > $TEMP_DIR/blast_hits_250_aa.gff\n"
	fi

	awk '($5-$4+1)/3>=250' $OUT_BEST_HIT > $TEMP_DIR/blast_hits_250_aa.gff

	# criteria 2
	if $VERBOSE; then
		wc -l $OUT_BEST_HIT | awk '{print $1, "hits remaining\n"}'
		echo -e "Criteria 2: add flanking sequences and find intact ORF (ATG ~ stop codon)"
		echo -e "
python $FINDORF $SUBJECT $TEMP_DIR/blast_hits_250_aa.gff |
bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |
python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/open_reading_frame.fa\n"
	fi

	# Uses included python script findorf.py to get potential orfs from all 6
	# reading frames for each blast hit coordinates
	# Get sequences for those orfs and calls fastatools translate function to
	# create a protein fasta file of all the orfs

	# Creates a file with subject chromosome/scaffold lengths for bedtools
	samtools faidx $SUBJECT
	cat $SUBJECT.fai |\
	cut -f 1,2 > $TEMP_DIR/sub.sizes

	bedtools slop -i $TEMP_DIR/blast_hits_250_aa.gff -g $TEMP_DIR/sub.sizes -b 1000 |\
	python $FINDORF -S $SUBJECT -H /dev/stdin |\
	bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |\
	python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/open_reading_frame.fa

	if [[ "$?" -ne 0 ]]; then
		echo -e "Error: when finding opening reading frames."
		exit 1
	fi

	# criteria 3
	if $VERBOSE; then
		awk '/>/ { count++ } END { print count, "remaining ORFs\n"}' $TEMP_DIR/open_reading_frame.fa
		echo -e "Criteria 3: multiple alignment and exclude or candidates which have long gaps (>=5) within transmembrane regions."
	fi


	# this divides the open reading frame file into fastas of 400 or less
	awk -v i=0 -v d=0 "/^>/ && i++%$ORF_MAX==0{s=\"$TEMP_DIR/open_reading_frame_\"++d\".fa\"} {print > s}" ${TEMP_DIR}/open_reading_frame.fa

	# Cycles through all of the reading frame fasta files
	i=0
	for FASTA in $TEMP_DIR/open_reading_frame_*.fa; do
		i=$((i+1))

		# puts the commands to be run in a text file
		# Adds the reference OR to the open reading frames
		# Aligns the sequences with MAFFT
		# Sends alignment along with OR REF and OR REF TM bed file to tm_gap
		# Gets back a GFF file with the start and stop of sequences with intact
		# TM regions.
		# Sends that to Bedtools to get a fasta from the subject sequence, then
		# translates the fastas, adds the OR REF, aligns with mafft, and sends
		# to a sequence alighnment fasta.
		echo "
cat $FASTA $OR_REF |\
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin |\
python $TM_GAP --ref_or $OR_REF --orf_aln /dev/stdin --ref_or_tm $OR_TM  --rem_id $REM_ID|\
bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |\
python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/excluded_long_gap_${i}.fa
		"
		done > $TEMP_DIR/command.txt

	if $VERBOSE; then
		echo -e "
For each group of $ORF_MAX ORFs:
cat $FASTA $OR_REF |
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin |
python $TM_GAP --ref_or $OR_REF --orf_aln /dev/stdin --ref_or_tm $OR_TM  --rem_id $REM_ID|
bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |
python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/excluded_long_gap_*.fa\n"
	fi

	cat $TEMP_DIR/command.txt | parallel -j $THREADS
	rm $TEMP_DIR/open_reading_frame_*.fa

	cat $TEMP_DIR/excluded_long_gap_*.fa > $TEMP_DIR/excluded_long_gap.fa
	rm $TEMP_DIR/excluded_long_gap_*.fa
	awk -v i=0 -v d=0 "/^>/ && i++%$ORF_MAX==0{s=\"${TEMP_DIR}/excluded_long_gap_\"++d\"_aln.fa\"} {print > s}" $TEMP_DIR/excluded_long_gap.fa

	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 3, exclude sequences with long gaps in transmembrane regions."
		exit 1
	fi

	# criteria 4
	if $VERBOSE; then
		awk '/>/ { count++ } END { print count, "remaining ORFs\n"}' $TEMP_DIR/excluded_long_gap.fa
		echo -e "Criteria 4: assigning a proper initiation codon"
	fi

	#Cycles through all the fasta files with intact TM regions
	i=0
	for FASTA in ${TEMP_DIR}/excluded_long_gap_*_aln.fa; do
		i=$((i+1))

		#Sends REFERENCE, OR_REF, OR_TM and FASTA to start codon
		echo -e "
cat $FASTA $OR_REF |\
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin |\
python $START_CODON --orf_aln /dev/stdin --ref_or_tm $OR_TM --rem_id $REM_ID|\
bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |\
python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/assigned_start_codon_${i}.fa.tmp"
	done > $TEMP_DIR/command.txt

	if $VERBOSE; then
		echo -e "
For each group of $ORF_MAX ORFs:
cat $FASTA $OR_REF |
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin |
python $START_CODON --orf_aln /dev/stdin --ref_or_tm $OR_TM --rem_id $REM_ID|
bedtools getfasta -s -fi $SUBJECT -bed /dev/stdin -fo /dev/stdout |
python $FASTATOOLS translate /dev/stdin > $TEMP_DIR/assigned_start_codon_${i}.fa.tmp
"
	fi

	cat $TEMP_DIR/command.txt | parallel -j $THREADS
	rm $TEMP_DIR/excluded_long_gap_*_aln.fa

	cat $TEMP_DIR/assigned_start_codon_*.fa.tmp > $TEMP_DIR/assigned_start_codon.fa
	rm $TEMP_DIR/assigned_start_codon_*.fa.tmp

	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 4, assigning a proper start codon."
		exit 1
	fi

	# phylogenetic tree
	#Split into 200 sequences
	awk "/^>/ && n++%200==0{s=\"$TEMP_DIR/assigned_start_codon_aa_\"++d\".fa\"} {print > s}" $TEMP_DIR/assigned_start_codon.fa
	# remove the description of the fasta sequences from heading
	bioawk -c fastx '{print ">"$1"\n"$2}' $OUTGROUP > "${TEMP_DIR}/outgroup.fa"
	i=0
	for FASTA in ${TEMP_DIR}/assigned_start_codon_aa_*.fa; do
		i=$((i+1))
		echo "
cat $FASTA $TEMP_DIR/outgroup.fa |\
mafft --maxiterate 1000 --genafpair --quiet --thread $THREADS /dev/stdin > $TEMP_DIR/assigned_start_codon_${i}_aln.fa"
	done > $TEMP_DIR/command.txt
	if $VERBOSE; then
		echo "
cat $FASTA $TEMP_DIR/outgroup.fa |
mafft --maxiterate 1000 --quiet --genafpair --thread $THREADS /dev/stdin > $TEMP_DIR/assigned_start_codon_${i}_aln.fa"
	fi

	cat $TEMP_DIR/command.txt | parallel -j $THREADS
	rm $TEMP_DIR/assigned_start_codon_aa_*.fa

	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 4, multiple sequence alignment for construction of phylogenetic tree."
		exit 1
	fi

	# megacc
	#Creates a text file with outgroup id = outgroup
	awk '{print $0"=outgroup"}' $OUT_ID > "${TEMP_DIR}/outgroup.txt"
	i=0

	for FASTA in ${TEMP_DIR}/assigned_start_codon_*_aln.fa; do
		i=$((i+1))
		echo "
megacc -a $MAO -d $FASTA -g ${TEMP_DIR}/outgroup.txt -o $TEMP_DIR/phylo_tree_${i}"
	done > ${TEMP_DIR}/command.txt

	if $VERBOSE; then
		echo "
megacc -a $MAO -d $FASTA -g ${TEMP_DIR}/outgroup.txt -o $TEMP_DIR/phylo_tree_${i}"
	fi

	cat ${TEMP_DIR}/command.txt | parallel -j $THREADS

	# discard non-OR genes that form a clade with the genes of outgroup
	bioawk -c fastx '{print $1}' $OUTGROUP | cut -f 2 -d '>' > ${TEMP_DIR}/outgroup_ids.txt
	i=0
	for NWK in ${TEMP_DIR}/phylo_tree_*.nwk; do
		i=$((i+1))
		echo "
python $PHYLO $NWK '${TEMP_DIR}/outgroup_ids.txt' > '${TEMP_DIR}/non_or_within_outgroup_ids_${i}.txt'"
	done > ${TEMP_DIR}/command.txt

	cat ${TEMP_DIR}/command.txt | parallel -j $THREADS

	cat ${TEMP_DIR}/non_or_within_outgroup_ids_*.txt > ${TEMP_DIR}/non_or_within_outgroup_ids.txt
	rm ${TEMP_DIR}/non_or_within_outgroup_ids_*.txt

	python $FASTATOOLS exclude ${TEMP_DIR}/assigned_start_codon.fa <( cat ${TEMP_DIR}/non_or_within_outgroup_ids.txt ) > $OUT_INTACT

	# rm -f $TEMP_DIR/phylo_tree_*

	if [[ "$?" -ne 0 ]]; then
		echo "Error: criteria 4, construction of phylogenetic tree."
		exit 1
	fi


	if ! $KEEP ; then
		rm -r $TEMP_DIR
	fi

	echo "done."

	exit 0
}

#identify pseudo genes
# function pseudo(){
# 	function pseudo_usage(){
# 		echo "
# usage:	orfam pseudo [options]
#
# options:
# 	-s FILE subject genome (fasta) (required)
# 	-q FILE query olfactory receptor proteins (fasta) (required)
# 	-b FILE best hits (gff) (required)
# 	-i FILE intact olfactory receptor (fasta) (required)
# 	-o STR 	output prefix
# 	-T DIR 	temp directory [./tmpXXXXXXXX]
# 	-k 		keep temporary files
# 	-K FILE path to orfam.config file (default: same directory as orfam)
# 	-v 		verbose
# 	-h 		show this message"
# 	}
#
# 	# check options passed in
# 	if [[ -z "$2" ]]; then
# 		pseudo_usage
# 		exit 1
# 	fi
#
# 	# set defaults
# 	ORFAM_DIR=$(dirname $0)
# 	CONFIG=$ORFAM_DIR/orfam.config
# 	SUBJECT=""
# 	QUERY=""
# 	BEST_HITS=""
# 	INTACT_GENE=""
# 	OUTPUT=""
# 	TEMP_DIR=""
# 	KEEP=0
# 	VERBOSE=0
#
# 	while getopts "hq:s:R:b:i:o:T:kK:v" OPTION; do
# 		case "$OPTION" in
# 			h)
# 				pseudo_usage
# 				exit 1
# 				;;
# 			s)
# 				SUBJECT="$OPTARG"
# 				;;
# 			q)
# 				QUERY="$OPTARG"
# 				;;
# 			b)
# 				BEST_HITS="$OPTARG"
# 				;;
# 			i)
# 				INTACT_GENE="$OPTARG"
# 				;;
# 			o)
# 				OUTPUT="$OPTARG"
# 				;;
# 			T)
# 				TEMP_DIR="$OPTARG"
# 				;;
# 			K)
# 				CONFIG="$OPTARG"
# 				;;
# 			v)
# 				VERBOSE=1
# 				;;
# 			k)
# 				KEEP=1
# 				;;
# 		esac
# 	done
#
# 	# check the relevant binaries
# 	source_binaries $CONFIG
#
# 	# check python modules
# 	check_python_modules $PYTHON
#
# 	if [[ ! -f $EXONERATE ]]; then
# 		pseudo_usage
# 		echo -e "Error: exonerate executable not found. Please set path in $ORFAM_DIR/orfam.config file."
# 		exit 1
# 	fi
# 	if [[ ! -f $PSEUDOGENE ]]; then
# 		pseudo_usage
# 		echo -e "Error: pseudogene.py executable not found. Please set path in $ORFAM_DIR/orfam.config file."
# 		exit 1
# 	fi
#
# 	# check that the required file exit
# 	if [[ ! -f $SUBJECT ]]; then
# 		pseudo_usage
# 		echo -e "Error: subject genome file $SUBJECT not found.\n"
# 		exit 1
# 	fi
#
# 	if [[ ! -f $QUERY ]]; then
# 		pseudo_usage
# 		echo -e "Error: query proteins file $QUERY not found.\n"
# 		exit 1
# 	fi
#
# 	if [[ ! -f $BEST_HITS ]]; then
# 		pseudo_usage
# 		echo -e "Error: best hits file $BEST_HITS not found.\n"
# 		exit 1
# 	fi
#
# 	if [[ ! -f $INTACT_GENE ]]; then
# 		pseudo_usage
# 		echo -e "Error: intact gene file $INTACT_GENE not found.\n"
# 		exit 1
# 	fi
#
# 	#make temporary directory
# 	if [[ -z "$TEMP_DIR" ]]; then
# 		TEMP_DIR=$( mktemp -d tmpXXXXXXXX )
# 	else
# 		mkdir -p $TEMP_DIR
# 	fi
#
# 	if [[ $VERBOSE -eq 1 ]]; then
# 		echo -e "
# 		$PYTHON $PSEUDOGENE -s $SUBJECT -q $QUERY -b $BEST_HITS -i $INTACT_GENE -T $TEMP_DIR
# 		"
# 	fi
#
# 	$PYTHON $PSEUDOGENE -s $SUBJECT -q $QUERY -b $BEST_HITS -i $INTACT_GENE -o $OUTPUT -T $TEMP_DIR
# }

# show usage when there are no arguments.
if [[ -z "$1" ]]; then
	usage
    exit 1
fi

while getopts "h:" OPTION; do
    case $OPTION in
        h)
            usage
            exit 1
            ;;
        ?)
            usage
            exit 1
            ;;
    esac
done

# call the function
case "$1" in
    'align')
    	align "${@:2}"
    	;;
    'func')
    	func "${@:2}"
    	;;
    'pseudo')
		pseudo "${@:2}"
		;;
    *)
    	usage
    	echo -e "Error: command \"$1\" is invalid\n"
    	exit 1
esac

## END SCRIPT
